{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"C:\\\\Users\\\\souha\\\\Desktop\\\\PFE Mast\\xE9re\\\\Getlearn1\\\\app_getlearn\\\\front\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar _objectSpread = require(\"C:\\\\Users\\\\souha\\\\Desktop\\\\PFE Mast\\xE9re\\\\Getlearn1\\\\app_getlearn\\\\front\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread2\");\n\nvar util = require('util');\n\nvar braces = require('braces');\n\nvar picomatch = require('picomatch');\n\nvar utils = require('picomatch/lib/utils');\n\nvar isEmptyString = function isEmptyString(val) {\n  return typeof val === 'string' && (val === '' || val === './');\n};\n/**\n * Returns an array of strings that match one or more glob patterns.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm(list, patterns[, options]);\n *\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\n * //=> [ 'a.js' ]\n * ```\n * @param {String|Array<string>} list List of strings to match.\n * @param {String|Array<string>} patterns One or more glob patterns to use for matching.\n * @param {Object} options See available [options](#options)\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */\n\n\nvar micromatch = function micromatch(list, patterns, options) {\n  patterns = [].concat(patterns);\n  list = [].concat(list);\n  var omit = new Set();\n  var keep = new Set();\n  var items = new Set();\n  var negatives = 0;\n\n  var onResult = function onResult(state) {\n    items.add(state.output);\n\n    if (options && options.onResult) {\n      options.onResult(state);\n    }\n  };\n\n  for (var i = 0; i < patterns.length; i++) {\n    var isMatch = picomatch(String(patterns[i]), _objectSpread({}, options, {\n      onResult: onResult\n    }), true);\n    var negated = isMatch.state.negated || isMatch.state.negatedExtglob;\n    if (negated) negatives++;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = list[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var item = _step.value;\n        var matched = isMatch(item, true);\n        var match = negated ? !matched.isMatch : matched.isMatch;\n        if (!match) continue;\n\n        if (negated) {\n          omit.add(matched.output);\n        } else {\n          omit.delete(matched.output);\n          keep.add(matched.output);\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  var result = negatives === patterns.length ? _toConsumableArray(items) : _toConsumableArray(keep);\n  var matches = result.filter(function (item) {\n    return !omit.has(item);\n  });\n\n  if (options && matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error(\"No matches found for \\\"\".concat(patterns.join(', '), \"\\\"\"));\n    }\n\n    if (options.nonull === true || options.nullglob === true) {\n      return options.unescape ? patterns.map(function (p) {\n        return p.replace(/\\\\/g, '');\n      }) : patterns;\n    }\n  }\n\n  return matches;\n};\n/**\n * Backwards compatibility\n */\n\n\nmicromatch.match = micromatch;\n/**\n * Returns a matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matcher(pattern[, options]);\n *\n * const isMatch = mm.matcher('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options`\n * @return {Function} Returns a matcher function.\n * @api public\n */\n\nmicromatch.matcher = function (pattern, options) {\n  return picomatch(pattern, options);\n};\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.isMatch(string, patterns[, options]);\n *\n * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(mm.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\nmicromatch.isMatch = function (str, patterns, options) {\n  return picomatch(patterns, options)(str);\n};\n/**\n * Backwards compatibility\n */\n\n\nmicromatch.any = micromatch.isMatch;\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.not(list, patterns[, options]);\n *\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\n * //=> ['b.b', 'c.c']\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */\n\nmicromatch.not = function (list, patterns) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  patterns = [].concat(patterns).map(String);\n  var result = new Set();\n  var items = [];\n\n  var onResult = function onResult(state) {\n    if (options.onResult) options.onResult(state);\n    items.push(state.output);\n  };\n\n  var matches = micromatch(list, patterns, _objectSpread({}, options, {\n    onResult: onResult\n  }));\n\n  for (var _i = 0, _items = items; _i < _items.length; _i++) {\n    var item = _items[_i];\n\n    if (!matches.includes(item)) {\n      result.add(item);\n    }\n  }\n\n  return _toConsumableArray(result);\n};\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var mm = require('micromatch');\n * // mm.contains(string, pattern[, options]);\n *\n * console.log(mm.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(mm.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the patter matches any part of `str`.\n * @api public\n */\n\n\nmicromatch.contains = function (str, pattern, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError(\"Expected a string: \\\"\".concat(util.inspect(str), \"\\\"\"));\n  }\n\n  if (Array.isArray(pattern)) {\n    return pattern.some(function (p) {\n      return micromatch.contains(str, p, options);\n    });\n  }\n\n  if (typeof pattern === 'string') {\n    if (isEmptyString(str) || isEmptyString(pattern)) {\n      return false;\n    }\n\n    if (str.includes(pattern) || str.startsWith('./') && str.slice(2).includes(pattern)) {\n      return true;\n    }\n  }\n\n  return micromatch.isMatch(str, pattern, _objectSpread({}, options, {\n    contains: true\n  }));\n};\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matchKeys(object, patterns[, options]);\n *\n * const obj = { aa: 'a', ab: 'b', ac: 'c' };\n * console.log(mm.matchKeys(obj, '*b'));\n * //=> { ab: 'b' }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */\n\n\nmicromatch.matchKeys = function (obj, patterns, options) {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('Expected the first argument to be an object');\n  }\n\n  var keys = micromatch(Object.keys(obj), patterns, options);\n  var res = {};\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var key = _step2.value;\n      res[key] = obj[key];\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return res;\n};\n/**\n * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.some(list, patterns[, options]);\n *\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // true\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\nmicromatch.some = function (list, patterns, options) {\n  var items = [].concat(list);\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    var _loop = function _loop() {\n      var pattern = _step3.value;\n      var isMatch = picomatch(String(pattern), options);\n\n      if (items.some(function (item) {\n        return isMatch(item);\n      })) {\n        return {\n          v: true\n        };\n      }\n    };\n\n    for (var _iterator3 = [].concat(patterns)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var _ret = _loop();\n\n      if (typeof _ret === \"object\") return _ret.v;\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  return false;\n};\n/**\n * Returns true if every string in the given `list` matches\n * any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.every(list, patterns[, options]);\n *\n * console.log(mm.every('foo.js', ['foo.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // false\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\nmicromatch.every = function (list, patterns, options) {\n  var items = [].concat(list);\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    var _loop2 = function _loop2() {\n      var pattern = _step4.value;\n      var isMatch = picomatch(String(pattern), options);\n\n      if (!items.every(function (item) {\n        return isMatch(item);\n      })) {\n        return {\n          v: false\n        };\n      }\n    };\n\n    for (var _iterator4 = [].concat(patterns)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var _ret2 = _loop2();\n\n      if (typeof _ret2 === \"object\") return _ret2.v;\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n\n  return true;\n};\n/**\n * Returns true if **all** of the given `patterns` match\n * the specified string.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.all(string, patterns[, options]);\n *\n * console.log(mm.all('foo.js', ['foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\n * // false\n *\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\n * // true\n * ```\n * @param {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\nmicromatch.all = function (str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError(\"Expected a string: \\\"\".concat(util.inspect(str), \"\\\"\"));\n  }\n\n  return [].concat(patterns).every(function (p) {\n    return picomatch(p, options)(str);\n  });\n};\n/**\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.capture(pattern, string[, options]);\n *\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `glob` Glob pattern to use for matching.\n * @param {String} `input` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns an array of captures if the input matches the glob pattern, otherwise `null`.\n * @api public\n */\n\n\nmicromatch.capture = function (glob, input, options) {\n  var posix = utils.isWindows(options);\n  var regex = picomatch.makeRe(String(glob), _objectSpread({}, options, {\n    capture: true\n  }));\n  var match = regex.exec(posix ? utils.toPosixSlashes(input) : input);\n\n  if (match) {\n    return match.slice(1).map(function (v) {\n      return v === void 0 ? '' : v;\n    });\n  }\n};\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.makeRe(pattern[, options]);\n *\n * console.log(mm.makeRe('*.js'));\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\n\nmicromatch.makeRe = function () {\n  return picomatch.makeRe.apply(picomatch, arguments);\n};\n/**\n * Scan a glob pattern to separate the pattern into segments. Used\n * by the [split](#split) method.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm.scan(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\n\nmicromatch.scan = function () {\n  return picomatch.scan.apply(picomatch, arguments);\n};\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm(pattern[, options]);\n * ```\n * @param {String} `glob`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as regex source string.\n * @api public\n */\n\n\nmicromatch.parse = function (patterns, options) {\n  var res = [];\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = [].concat(patterns || [])[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var pattern = _step5.value;\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = braces(String(pattern), options)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var str = _step6.value;\n          res.push(picomatch.parse(str, options));\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n\n  return res;\n};\n/**\n * Process the given brace `pattern`.\n *\n * ```js\n * const { braces } = require('micromatch');\n * console.log(braces('foo/{a,b,c}/bar'));\n * //=> [ 'foo/(a|b|c)/bar' ]\n *\n * console.log(braces('foo/{a,b,c}/bar', { expand: true }));\n * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]\n * ```\n * @param {String} `pattern` String with brace pattern to process.\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\n * @return {Array}\n * @api public\n */\n\n\nmicromatch.braces = function (pattern, options) {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n\n  if (options && options.nobrace === true || !/\\{.*\\}/.test(pattern)) {\n    return [pattern];\n  }\n\n  return braces(pattern, options);\n};\n/**\n * Expand braces\n */\n\n\nmicromatch.braceExpand = function (pattern, options) {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n  return micromatch.braces(pattern, _objectSpread({}, options, {\n    expand: true\n  }));\n};\n/**\n * Expose micromatch\n */\n\n\nmodule.exports = micromatch;","map":{"version":3,"sources":["C:/Users/souha/Desktop/PFE Mastére/Getlearn1/app_getlearn/front/node_modules/http-proxy-middleware/node_modules/micromatch/index.js"],"names":["util","require","braces","picomatch","utils","isEmptyString","val","micromatch","list","patterns","options","concat","omit","Set","keep","items","negatives","onResult","state","add","output","i","length","isMatch","String","negated","negatedExtglob","item","matched","match","delete","result","matches","filter","has","failglob","Error","join","nonull","nullglob","unescape","map","p","replace","matcher","pattern","str","any","not","push","includes","contains","TypeError","inspect","Array","isArray","some","startsWith","slice","matchKeys","obj","isObject","keys","Object","res","key","every","all","capture","glob","input","posix","isWindows","regex","makeRe","exec","toPosixSlashes","v","scan","parse","nobrace","test","braceExpand","expand","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst util = require('util');\nconst braces = require('braces');\nconst picomatch = require('picomatch');\nconst utils = require('picomatch/lib/utils');\nconst isEmptyString = val => typeof val === 'string' && (val === '' || val === './');\n\n/**\n * Returns an array of strings that match one or more glob patterns.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm(list, patterns[, options]);\n *\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\n * //=> [ 'a.js' ]\n * ```\n * @param {String|Array<string>} list List of strings to match.\n * @param {String|Array<string>} patterns One or more glob patterns to use for matching.\n * @param {Object} options See available [options](#options)\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */\n\nconst micromatch = (list, patterns, options) => {\n  patterns = [].concat(patterns);\n  list = [].concat(list);\n\n  let omit = new Set();\n  let keep = new Set();\n  let items = new Set();\n  let negatives = 0;\n\n  let onResult = state => {\n    items.add(state.output);\n    if (options && options.onResult) {\n      options.onResult(state);\n    }\n  };\n\n  for (let i = 0; i < patterns.length; i++) {\n    let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);\n    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;\n    if (negated) negatives++;\n\n    for (let item of list) {\n      let matched = isMatch(item, true);\n\n      let match = negated ? !matched.isMatch : matched.isMatch;\n      if (!match) continue;\n\n      if (negated) {\n        omit.add(matched.output);\n      } else {\n        omit.delete(matched.output);\n        keep.add(matched.output);\n      }\n    }\n  }\n\n  let result = negatives === patterns.length ? [...items] : [...keep];\n  let matches = result.filter(item => !omit.has(item));\n\n  if (options && matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error(`No matches found for \"${patterns.join(', ')}\"`);\n    }\n\n    if (options.nonull === true || options.nullglob === true) {\n      return options.unescape ? patterns.map(p => p.replace(/\\\\/g, '')) : patterns;\n    }\n  }\n\n  return matches;\n};\n\n/**\n * Backwards compatibility\n */\n\nmicromatch.match = micromatch;\n\n/**\n * Returns a matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matcher(pattern[, options]);\n *\n * const isMatch = mm.matcher('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options`\n * @return {Function} Returns a matcher function.\n * @api public\n */\n\nmicromatch.matcher = (pattern, options) => picomatch(pattern, options);\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.isMatch(string, patterns[, options]);\n *\n * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(mm.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Backwards compatibility\n */\n\nmicromatch.any = micromatch.isMatch;\n\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.not(list, patterns[, options]);\n *\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\n * //=> ['b.b', 'c.c']\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */\n\nmicromatch.not = (list, patterns, options = {}) => {\n  patterns = [].concat(patterns).map(String);\n  let result = new Set();\n  let items = [];\n\n  let onResult = state => {\n    if (options.onResult) options.onResult(state);\n    items.push(state.output);\n  };\n\n  let matches = micromatch(list, patterns, { ...options, onResult });\n\n  for (let item of items) {\n    if (!matches.includes(item)) {\n      result.add(item);\n    }\n  }\n  return [...result];\n};\n\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var mm = require('micromatch');\n * // mm.contains(string, pattern[, options]);\n *\n * console.log(mm.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(mm.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the patter matches any part of `str`.\n * @api public\n */\n\nmicromatch.contains = (str, pattern, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n\n  if (Array.isArray(pattern)) {\n    return pattern.some(p => micromatch.contains(str, p, options));\n  }\n\n  if (typeof pattern === 'string') {\n    if (isEmptyString(str) || isEmptyString(pattern)) {\n      return false;\n    }\n\n    if (str.includes(pattern) || (str.startsWith('./') && str.slice(2).includes(pattern))) {\n      return true;\n    }\n  }\n\n  return micromatch.isMatch(str, pattern, { ...options, contains: true });\n};\n\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matchKeys(object, patterns[, options]);\n *\n * const obj = { aa: 'a', ab: 'b', ac: 'c' };\n * console.log(mm.matchKeys(obj, '*b'));\n * //=> { ab: 'b' }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */\n\nmicromatch.matchKeys = (obj, patterns, options) => {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('Expected the first argument to be an object');\n  }\n  let keys = micromatch(Object.keys(obj), patterns, options);\n  let res = {};\n  for (let key of keys) res[key] = obj[key];\n  return res;\n};\n\n/**\n * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.some(list, patterns[, options]);\n *\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // true\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.some = (list, patterns, options) => {\n  let items = [].concat(list);\n\n  for (let pattern of [].concat(patterns)) {\n    let isMatch = picomatch(String(pattern), options);\n    if (items.some(item => isMatch(item))) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if every string in the given `list` matches\n * any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.every(list, patterns[, options]);\n *\n * console.log(mm.every('foo.js', ['foo.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // false\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.every = (list, patterns, options) => {\n  let items = [].concat(list);\n\n  for (let pattern of [].concat(patterns)) {\n    let isMatch = picomatch(String(pattern), options);\n    if (!items.every(item => isMatch(item))) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns true if **all** of the given `patterns` match\n * the specified string.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.all(string, patterns[, options]);\n *\n * console.log(mm.all('foo.js', ['foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\n * // false\n *\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\n * // true\n * ```\n * @param {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.all = (str, patterns, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n\n  return [].concat(patterns).every(p => picomatch(p, options)(str));\n};\n\n/**\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.capture(pattern, string[, options]);\n *\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `glob` Glob pattern to use for matching.\n * @param {String} `input` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns an array of captures if the input matches the glob pattern, otherwise `null`.\n * @api public\n */\n\nmicromatch.capture = (glob, input, options) => {\n  let posix = utils.isWindows(options);\n  let regex = picomatch.makeRe(String(glob), { ...options, capture: true });\n  let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);\n\n  if (match) {\n    return match.slice(1).map(v => v === void 0 ? '' : v);\n  }\n};\n\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.makeRe(pattern[, options]);\n *\n * console.log(mm.makeRe('*.js'));\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\nmicromatch.makeRe = (...args) => picomatch.makeRe(...args);\n\n/**\n * Scan a glob pattern to separate the pattern into segments. Used\n * by the [split](#split) method.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm.scan(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\nmicromatch.scan = (...args) => picomatch.scan(...args);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm(pattern[, options]);\n * ```\n * @param {String} `glob`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as regex source string.\n * @api public\n */\n\nmicromatch.parse = (patterns, options) => {\n  let res = [];\n  for (let pattern of [].concat(patterns || [])) {\n    for (let str of braces(String(pattern), options)) {\n      res.push(picomatch.parse(str, options));\n    }\n  }\n  return res;\n};\n\n/**\n * Process the given brace `pattern`.\n *\n * ```js\n * const { braces } = require('micromatch');\n * console.log(braces('foo/{a,b,c}/bar'));\n * //=> [ 'foo/(a|b|c)/bar' ]\n *\n * console.log(braces('foo/{a,b,c}/bar', { expand: true }));\n * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]\n * ```\n * @param {String} `pattern` String with brace pattern to process.\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\n * @return {Array}\n * @api public\n */\n\nmicromatch.braces = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n  if ((options && options.nobrace === true) || !/\\{.*\\}/.test(pattern)) {\n    return [pattern];\n  }\n  return braces(pattern, options);\n};\n\n/**\n * Expand braces\n */\n\nmicromatch.braceExpand = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n  return micromatch.braces(pattern, { ...options, expand: true });\n};\n\n/**\n * Expose micromatch\n */\n\nmodule.exports = micromatch;\n"]},"metadata":{},"sourceType":"script"}